#!/usr/bin/env python
"""
cask-w - Send message to Codex and wait for reply (foreground sync).

stdout: reply text only (for piping).
stderr: progress and errors.
"""
from __future__ import annotations
import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()


def main(argv: list[str]) -> int:
    from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK, atomic_write_text
    from codex_comm import CodexCommunicator
    from i18n import t

    if len(argv) <= 1:
        print("Usage: cask-w [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)
        return EXIT_ERROR

    output_path: Path | None = None
    timeout: float | None = None

    parts: list[str] = []
    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            print("Usage: cask-w [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)
            return EXIT_OK
        if token in ("-o", "--output"):
            try:
                output_path = Path(next(it)).expanduser()
            except StopIteration:
                print("‚ùå --output requires a file path", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("‚ùå --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("‚ùå --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message:
        print("‚ùå Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        except Exception:
            timeout = 3600.0

    try:
        comm = CodexCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            print(f"‚ùå Session error: {status}", file=sys.stderr)
            return EXIT_ERROR

        # Send message
        print(f"üîî {t('sending_to', provider='Codex')}", file=sys.stderr, flush=True)
        _, state = comm._send_message(message)

        message_reply, _ = comm.log_reader.wait_for_message(state, timeout)
        if not message_reply:
            print(f"‚è∞ Timeout after {int(timeout)}s", file=sys.stderr)
            return EXIT_NO_REPLY

        if output_path:
            atomic_write_text(output_path, message_reply + "\n")

        sys.stdout.write(message_reply)
        if not message_reply.endswith("\n"):
            sys.stdout.write("\n")
        return EXIT_OK

    except KeyboardInterrupt:
        print("‚ùå Interrupted", file=sys.stderr)
        return 130
    except Exception as exc:
        print(f"‚ùå {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
