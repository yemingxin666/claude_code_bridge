#!/usr/bin/env python3
"""
ccb (Claude Code Bridge) - Unified AI Launcher
Supports Claude + Codex / Claude + Gemini / all three simultaneously
Supports tmux, WezTerm and iTerm2 terminals
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
import tempfile
import re
import shutil
import posixpath
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import TmuxBackend, WeztermBackend, Iterm2Backend, detect_terminal, is_wsl, get_shell_type
from compat import setup_windows_encoding
from ccb_config import get_backend_env
from session_utils import safe_write_session, check_session_writable
from i18n import t

setup_windows_encoding()

backend_env = get_backend_env()
if backend_env and not os.environ.get("CCB_BACKEND_ENV"):
    os.environ["CCB_BACKEND_ENV"] = backend_env

VERSION = "2.2"
GIT_COMMIT = ""
GIT_DATE = ""

_WIN_DRIVE_RE = re.compile(r"^[A-Za-z]:([/\\\\]|$)")
_MNT_DRIVE_RE = re.compile(r"^/mnt/([A-Za-z])/(.*)$")
_MSYS_DRIVE_RE = re.compile(r"^/([A-Za-z])/(.*)$")


def _looks_like_windows_path(value: str) -> bool:
    s = value.strip()
    if not s:
        return False
    if _WIN_DRIVE_RE.match(s):
        return True
    if s.startswith("\\\\") or s.startswith("//"):
        return True
    return False


def _normalize_path_for_match(value: str) -> str:
    """
    Normalize a path-like string for loose matching across Windows/WSL/MSYS variations.
    This is used only for selecting a session for *current* cwd, so favor robustness.
    """
    s = (value or "").strip()
    if not s:
        return ""

    # Expand "~" early (common in shell-originated values). If expansion fails, keep original.
    if s.startswith("~"):
        try:
            s = os.path.expanduser(s)
        except Exception:
            pass

    # If the path is relative, absolutize it against current cwd for matching purposes only.
    # This reduces false negatives when upstream tools record a relative cwd.
    # NOTE: treat Windows-like absolute paths as absolute even on non-Windows hosts.
    try:
        preview = s.replace("\\", "/")
        is_abs = (
            preview.startswith("/")
            or preview.startswith("//")
            or bool(_WIN_DRIVE_RE.match(preview))
            or preview.startswith("\\\\")
        )
        if not is_abs:
            s = str((Path.cwd() / Path(s)).absolute())
    except Exception:
        pass

    s = s.replace("\\", "/")

    # Map WSL drive mount to Windows-style drive path for comparison.
    m = _MNT_DRIVE_RE.match(s)
    if m:
        drive = m.group(1).lower()
        rest = m.group(2)
        s = f"{drive}:/{rest}"
    else:
        # Map MSYS /c/... to c:/... (Git-Bash/MSYS2 environments on Windows).
        m = _MSYS_DRIVE_RE.match(s)
        if m and ("MSYSTEM" in os.environ or os.name == "nt"):
            drive = m.group(1).lower()
            rest = m.group(2)
            s = f"{drive}:/{rest}"

    # Collapse redundant separators and dot segments using POSIX semantics (we forced "/").
    # Preserve UNC double-slash prefix.
    if s.startswith("//"):
        prefix = "//"
        rest = s[2:]
        rest = posixpath.normpath(rest)
        s = prefix + rest.lstrip("/")
    else:
        s = posixpath.normpath(s)

    # Normalize Windows drive letter casing (c:/..., not C:/...).
    if _WIN_DRIVE_RE.match(s):
        s = s[0].lower() + s[1:]

    # Drop trailing slash (but keep "/" and "c:/").
    if len(s) > 1 and s.endswith("/"):
        s = s.rstrip("/")
        if _WIN_DRIVE_RE.match(s) and not s.endswith("/"):
            # Ensure drive root keeps trailing slash form "c:/".
            if len(s) == 2:
                s = s + "/"

    # On Windows-like paths, compare case-insensitively to avoid drive letter/case issues.
    if _looks_like_windows_path(s):
        s = s.casefold()

    return s


def _work_dir_match_keys(work_dir: Path) -> set[str]:
    keys: set[str] = set()
    candidates: list[str] = []
    for raw in (os.environ.get("PWD"), str(work_dir)):
        if raw:
            candidates.append(raw)
    try:
        candidates.append(str(work_dir.resolve()))
    except Exception:
        pass
    for candidate in candidates:
        normalized = _normalize_path_for_match(candidate)
        if normalized:
            keys.add(normalized)
    return keys


def _extract_session_work_dir_norm(session_data: dict) -> str:
    """Extract a normalized work dir marker from a session file payload."""
    if not isinstance(session_data, dict):
        return ""
    raw_norm = session_data.get("work_dir_norm")
    if isinstance(raw_norm, str) and raw_norm.strip():
        return _normalize_path_for_match(raw_norm)
    raw = session_data.get("work_dir")
    if isinstance(raw, str) and raw.strip():
        return _normalize_path_for_match(raw)
    return ""


def _get_git_info() -> str:
    try:
        result = subprocess.run(
            ["git", "-C", str(script_dir), "log", "-1", "--format=%h %ci"],
            capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=2
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except Exception:
        pass
    return ""


def _build_keep_open_cmd(provider: str, start_cmd: str) -> str:
    if get_shell_type() == "powershell":
        return (
            f'{start_cmd}; '
            f'$code = $LASTEXITCODE; '
            f'Write-Host "`n[{provider}] exited with code $code. Press Enter to close..."; '
            f'Read-Host; '
            f'exit $code'
        )
    return (
        f'{start_cmd}; '
        f'code=$?; '
        f'echo; echo "[{provider}] exited with code $code. Press Enter to close..."; '
        f'read -r _; '
        f'exit $code'
    )


class AILauncher:
    def __init__(self, providers: list, resume: bool = False, auto: bool = False, no_claude: bool = False):
        self.providers = providers or ["codex"]
        self.resume = resume
        self.auto = auto
        self.no_claude = no_claude
        self.script_dir = Path(__file__).resolve().parent
        self.session_id = f"ai-{int(time.time())}-{os.getpid()}"
        self.temp_base = Path(tempfile.gettempdir())
        self.runtime_dir = self.temp_base / f"claude-ai-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)
        self._cleaned = False
        self.terminal_type = self._detect_terminal_type()
        self.tmux_sessions = {}
        self.wezterm_panes = {}
        self.iterm2_panes = {}
        self.processes = {}

    def _detect_terminal_type(self):
        # Forced by environment variable
        forced = (os.environ.get("CCB_TERMINAL") or os.environ.get("CODEX_TERMINAL") or "").strip().lower()
        if forced in {"wezterm", "tmux"}:
            return forced

        # When inside WezTerm pane, force wezterm, no tmux dependency
        if os.environ.get("WEZTERM_PANE"):
            return "wezterm"
        # Only use iTerm2 split when in iTerm2 environment
        if os.environ.get("ITERM_SESSION_ID"):
            return "iterm2"

        # Use detect_terminal() for auto-detection (WezTerm preferred)
        detected = detect_terminal()
        if detected:
            return detected

        # Fallback: if nothing found, return None for later handling
        return None

    def _detect_launch_terminal(self):
        """Select terminal program for launching new windows (tmux mode only)"""
        # WezTerm mode doesn't need external terminal program
        if self.terminal_type == "wezterm":
            return None
        # tmux mode: select terminal
        terminals = ["gnome-terminal", "konsole", "alacritty", "xterm"]
        for term in terminals:
            if shutil.which(term):
                return term
        return "tmux"

    def _launch_script_in_macos_terminal(self, script_file: Path) -> bool:
        """macOS: Use Terminal.app to open new window for script (avoid tmux launcher nesting issues)"""
        if platform.system() != "Darwin":
            return False
        if not shutil.which("osascript"):
            return False
        env = os.environ.copy()
        env["CCB_WRAPPER_SCRIPT"] = str(script_file)
        subprocess.Popen(
            [
                "osascript",
                "-e",
                'tell application "Terminal" to do script "/bin/bash " & quoted form of (system attribute "CCB_WRAPPER_SCRIPT")',
                "-e",
                'tell application "Terminal" to activate',
            ],
            env=env,
        )
        return True

    def _start_provider(self, provider: str) -> bool:
        # Handle case when no terminal detected
        if self.terminal_type is None:
            print(f"âŒ {t('no_terminal_backend')}")
            print(f"   {t('solutions')}")
            print(f"   - {t('install_wezterm')}")
            print(f"   - {t('or_install_tmux')}")
            print(f"   - {t('or_set_ccb_terminal')}")
            return False

        # WezTerm mode: no tmux dependency
        if self.terminal_type == "wezterm":
            print(f"ðŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='wezterm')}")
            return self._start_provider_wezterm(provider)
        elif self.terminal_type == "iterm2":
            return self._start_provider_iterm2(provider)

        # tmux mode: check if tmux is available
        if not shutil.which("tmux"):
            # Try fallback to WezTerm
            if detect_terminal() == "wezterm":
                self.terminal_type = "wezterm"
                print(f"ðŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='wezterm - tmux unavailable')}")
                return self._start_provider_wezterm(provider)
            else:
                print(f"âŒ {t('tmux_not_installed')}")
                print(f"   {t('install_wezterm_or_tmux')}")
                return False

        print(f"ðŸš€ {t('starting_backend', provider=provider.capitalize(), terminal='tmux')}")

        tmux_session = f"{provider}-{int(time.time()) % 100000}-{os.getpid()}"
        self.tmux_sessions[provider] = tmux_session

        if provider == "codex":
            return self._start_codex(tmux_session)
        elif provider == "gemini":
            return self._start_gemini(tmux_session)
        else:
            print(f"âŒ {t('unknown_provider', provider=provider)}")
            return False

    def _start_provider_wezterm(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        keep_open = os.environ.get("CODEX_WEZTERM_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = _build_keep_open_cmd(provider, start_cmd)
        # Layout: first backend splits to the right of current pane, subsequent backends stack below
        # the first backend pane to form a right-side column (top/bottom).
        direction = "right" if not self.wezterm_panes else "bottom"
        parent_pane = None
        if direction == "bottom":
            try:
                parent_pane = next(iter(self.wezterm_panes.values()))
            except StopIteration:
                parent_pane = None

        backend = WeztermBackend()
        pane_id = backend.create_pane(start_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.wezterm_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # WezTerm mode injects text via pane, no strong FIFO dependency; Windows/WSL may not support mkfifo
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id)
        else:
            self._write_gemini_session(runtime, None, pane_id=pane_id)

        print(f"âœ… {t('started_backend', provider=provider.capitalize(), terminal='wezterm pane', pane_id=pane_id)}")
        return True

    def _start_provider_iterm2(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        # In iTerm2 split, process exit will close pane; keep pane open by default to view exit info
        keep_open = os.environ.get("CODEX_ITERM2_KEEP_OPEN", "1").lower() not in {"0", "false", "no", "off"}
        if keep_open:
            start_cmd = (
                f"{start_cmd}; "
                f"code=$?; "
                f'echo; echo \"[{provider}] exited with code $code. Press Enter to close...\"; '
                f"read -r _; "
                f"exit $code"
            )
        # Layout: first backend splits to the right of current pane, subsequent backends stack below
        direction = "right" if not self.iterm2_panes else "bottom"
        parent_pane = None
        if direction == "bottom":
            try:
                parent_pane = next(iter(self.iterm2_panes.values()))
            except StopIteration:
                parent_pane = None

        backend = Iterm2Backend()
        pane_id = backend.create_pane(start_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.iterm2_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            # iTerm2 mode injects text via pane, no strong FIFO dependency
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id)
        else:
            self._write_gemini_session(runtime, None, pane_id=pane_id)

        print(f"âœ… {t('started_backend', provider=provider.capitalize(), terminal='iterm2 session', pane_id=pane_id)}")
        return True

    def _work_dir_strings(self, work_dir: Path) -> list[str]:
        candidates: list[str] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            candidates.append(env_pwd)
        candidates.append(str(work_dir))
        try:
            candidates.append(str(work_dir.resolve()))
        except Exception:
            pass
        # de-dup while preserving order
        seen: set[str] = set()
        result: list[str] = []
        for candidate in candidates:
            if candidate not in seen:
                seen.add(candidate)
                result.append(candidate)
        return result

    def _read_json_file(self, path: Path) -> dict:
        try:
            if not path.exists():
                return {}
            # Session files are written as UTF-8; on Windows PowerShell 5.1 the default encoding
            # may not be UTF-8, so always decode explicitly and tolerate UTF-8 BOM.
            raw = path.read_text(encoding="utf-8-sig")
            data = json.loads(raw)
            return data if isinstance(data, dict) else {}
        except Exception:
            return {}

    def _write_json_file(self, path: Path, data: dict) -> None:
        try:
            path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            pass

    def _claude_session_file(self) -> Path:
        return Path.cwd() / ".claude-session"

    def _read_local_claude_session_id(self) -> str | None:
        data = self._read_json_file(self._claude_session_file())
        sid = data.get("claude_session_id") or data.get("session_id")
        if isinstance(sid, str) and sid.strip():
            # Guard against path-format mismatch (Windows case/slash differences, MSYS paths, etc.).
            recorded_norm = _extract_session_work_dir_norm(data)
            if not recorded_norm:
                # Old/foreign session file without a recorded work dir: refuse to resume to avoid cross-project reuse.
                return None
            current_keys = _work_dir_match_keys(Path.cwd())
            if current_keys and recorded_norm not in current_keys:
                return None
            return sid.strip()
        return None

    def _write_local_claude_session(self, session_id: str, active: bool = True) -> None:
        path = self._claude_session_file()
        data = self._read_json_file(path)
        work_dir = Path.cwd()
        data.update(
            {
                "claude_session_id": session_id,
                "work_dir": str(work_dir),
                "work_dir_norm": _normalize_path_for_match(str(work_dir)),
                "active": bool(active),
                "started_at": data.get("started_at") or time.strftime("%Y-%m-%d %H:%M:%S"),
                "updated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
            }
        )
        self._write_json_file(path, data)

    def _get_latest_codex_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history_for_cwd).
        Session id is Codex CLI's UUID used by `codex resume <id>`.
        Always scans session logs to find the latest session for current cwd,
        then updates local .codex-session file.
        """
        project_session = Path.cwd() / ".codex-session"

        # Always scan Codex session logs for the latest session bound to this cwd.
        # This ensures we get the latest session even if user did /clear during run.
        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
        if not root.exists():
            return None, False
        work_keys = _work_dir_match_keys(Path.cwd())
        if not work_keys:
            return None, False
        try:
            logs = sorted(
                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                key=lambda p: p.stat().st_mtime,
                reverse=True,
            )
        except Exception:
            logs = []
        for log_path in logs[:400]:
            try:
                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                    first = handle.readline().strip()
            except OSError:
                continue
            if not first:
                continue
            try:
                entry = json.loads(first)
            except Exception:
                continue
            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                continue
            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
            cwd = payload.get("cwd")
            if not isinstance(cwd, str) or not cwd.strip():
                continue
            if _normalize_path_for_match(cwd) not in work_keys:
                continue
            sid = payload.get("id")
            if isinstance(sid, str) and sid:
                # Update local .codex-session file with latest session id
                data = self._read_json_file(project_session) if project_session.exists() else {}
                work_dir = Path.cwd()
                data.update({
                    "codex_session_id": sid,
                    "work_dir": str(work_dir),
                    "work_dir_norm": _normalize_path_for_match(str(work_dir)),
                    "updated_at": time.strftime("%Y-%m-%d %H:%M:%S"),
                })
                self._write_json_file(project_session, data)
                return sid, True
        return None, False

    def _build_codex_start_cmd(self) -> str:
        cmd = "codex -c disable_paste_burst=true --full-auto" if self.auto else "codex -c disable_paste_burst=true"
        codex_resumed = False
        if self.resume:
            session_id, has_history = self._get_latest_codex_session_id()
            if session_id:
                cmd = f"{cmd} resume {session_id}"
                print(f"ðŸ” {t('resuming_session', provider='Codex', session_id=session_id[:8])}")
                codex_resumed = True

            if not codex_resumed:
                print(f"â„¹ï¸ {t('no_history_fresh', provider='Codex')}")
        return cmd

    def _get_latest_gemini_project_hash(self) -> tuple[str | None, bool]:
        """
        Returns (project_hash, has_any_history_for_cwd).
        Gemini CLI stores sessions under ~/.gemini/tmp/<sha256(cwd)>/chats/.
        """
        import hashlib

        gemini_root = Path(os.environ.get("GEMINI_ROOT") or (Path.home() / ".gemini" / "tmp")).expanduser()

        candidates: list[str] = []
        try:
            candidates.append(str(Path.cwd().absolute()))
        except Exception:
            pass
        try:
            candidates.append(str(Path.cwd().resolve()))
        except Exception:
            pass
        env_pwd = (os.environ.get("PWD") or "").strip()
        if env_pwd:
            try:
                candidates.append(os.path.abspath(os.path.expanduser(env_pwd)))
            except Exception:
                candidates.append(env_pwd)

        seen: set[str] = set()
        for candidate in candidates:
            if not candidate or candidate in seen:
                continue
            seen.add(candidate)
            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
            chats_dir = gemini_root / project_hash / "chats"
            if not chats_dir.exists():
                continue
            session_files = list(chats_dir.glob("session-*.json"))
            if session_files:
                return project_hash, True

        return None, False

    def _build_gemini_start_cmd(self) -> str:
        cmd = "gemini --yolo" if self.auto else "gemini"
        if self.resume:
            _, has_history = self._get_latest_gemini_project_hash()
            if has_history:
                cmd = f"{cmd} --resume latest"
                print(f"ðŸ” {t('resuming_session', provider='Gemini', session_id='')}")
            else:
                print(f"â„¹ï¸ {t('no_history_fresh', provider='Gemini')}")
        return cmd

    def _warmup_provider(self, provider: str, timeout: float = 8.0) -> bool:
        if provider == "codex":
            ping_script = self.script_dir / "bin" / "cping"
        elif provider == "gemini":
            ping_script = self.script_dir / "bin" / "gping"
        else:
            return False

        if not ping_script.exists():
            return False

        print(f"ðŸ”§ Warmup: {ping_script.name}")
        deadline = time.time() + timeout
        last_result: subprocess.CompletedProcess[str] | None = None
        sleep_s = 0.3
        while time.time() < deadline:
            last_result = subprocess.run(
                [sys.executable, str(ping_script)],
                cwd=str(Path.cwd()),
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace',
            )
            if last_result.returncode == 0:
                out = (last_result.stdout or "").strip()
                if out:
                    print(out)
                return True
            time.sleep(sleep_s)
            sleep_s = min(1.0, sleep_s * 1.5)

        if last_result:
            out = ((last_result.stdout or "") + "\n" + (last_result.stderr or "")).strip()
            if out:
                print(out)
        print(f"âš ï¸ Warmup failed: {provider}")
        return False

    def _get_start_cmd(self, provider: str) -> str:
        if provider == "codex":
            # NOTE: Codex TUI has paste-burst detection; terminal injection (wezterm send-text/tmux paste-buffer)
            # is often detected as "paste", causing Enter to only line-break not submit. Disable detection by default.
            return self._build_codex_start_cmd()
        elif provider == "gemini":
            return self._build_gemini_start_cmd()
        return ""

    def _start_codex(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "codex"
        runtime.mkdir(parents=True, exist_ok=True)

        input_fifo = runtime / "input.fifo"
        output_fifo = runtime / "output.fifo"

        if not input_fifo.exists():
            os.mkfifo(input_fifo, 0o600)
        if not output_fifo.exists():
            os.mkfifo(output_fifo, 0o644)

        start_cmd = self._build_codex_start_cmd()

        bridge_script = self.script_dir / "lib" / "codex_dual_bridge.py"
        wrapper = f'''#!/bin/bash
SESSION_ID="{self.session_id}"
RUNTIME_DIR="{runtime}"
TMUX_SESSION="{tmux_session}"
BRIDGE_SCRIPT="{bridge_script}"
PYTHON_BIN="{sys.executable}"
SCRIPT_DIR="{self.script_dir}"
WORK_DIR="{os.getcwd()}"
INPUT_FIFO="{input_fifo}"
OUTPUT_FIFO="{output_fifo}"
TMUX_LOG_FILE="{runtime}/bridge_output.log"

echo $$ > "$RUNTIME_DIR/codex.pid"
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_INPUT_FIFO="$INPUT_FIFO"
export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
export CODEX_TMUX_SESSION="$TMUX_SESSION"
export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

CODEX_START_CMD={json.dumps(start_cmd)}

if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    cd "$WORK_DIR"
    tmux new-session -d -s "$TMUX_SESSION" "$CODEX_START_CMD"
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$RUNTIME_DIR/bridge.log" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$RUNTIME_DIR/bridge.pid"

trap 'kill -TERM "$BRIDGE_PID" 2>/dev/null' EXIT
exec tmux attach -t "$TMUX_SESSION"
'''
        script_file = runtime / "wrapper.sh"
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        self._write_codex_session(runtime, tmux_session, input_fifo, output_fifo)

        terminal = self._detect_launch_terminal()
        if terminal == "tmux":
            if self._launch_script_in_macos_terminal(script_file):
                pass
            else:
                subprocess.run(["tmux", "new-session", "-d", "-s", f"launcher-{tmux_session}", str(script_file)], check=True)
        else:
            subprocess.Popen([terminal, "-e", str(script_file)])

        print(f"âœ… {t('started_backend', provider='Codex', terminal='tmux', pane_id=tmux_session)}")
        return True

    def _start_gemini(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "gemini"
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._build_gemini_start_cmd()

        script_file = runtime / "wrapper.sh"

        self._write_gemini_session(runtime, tmux_session)

        # Create startup script
        wrapper = f'''#!/bin/bash
	cd "{os.getcwd()}"
	tmux new-session -d -s "{tmux_session}" 2>/dev/null || true
	tmux send-keys -t "{tmux_session}" "{start_cmd}" Enter
	exec tmux attach -t "{tmux_session}"
	'''
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        terminal = self._detect_launch_terminal()
        if terminal == "tmux":
            if self._launch_script_in_macos_terminal(script_file):
                pass
            else:
                # Pure tmux mode
                subprocess.run(["tmux", "new-session", "-d", "-s", tmux_session], check=True, cwd=os.getcwd())
                backend = TmuxBackend()
                deadline = time.time() + 1.0
                sleep_s = 0.05
                while True:
                    try:
                        backend.send_text(tmux_session, start_cmd)
                        break
                    except subprocess.CalledProcessError:
                        if time.time() >= deadline:
                            raise
                        time.sleep(sleep_s)
                        sleep_s = min(0.2, sleep_s * 2)
        else:
            # Open new terminal window
            subprocess.Popen([terminal, "--", str(script_file)])

        print(f"âœ… {t('started_backend', provider='Gemini', terminal='tmux', pane_id=tmux_session)}")
        return True

    def _write_codex_session(self, runtime, tmux_session, input_fifo, output_fifo, pane_id=None):
        session_file = Path.cwd() / ".codex-session"

        # Pre-check permissions
        writable, reason, fix = check_session_writable(session_file)
        if not writable:
            print(f"âŒ Cannot write {session_file.name}: {reason}", file=sys.stderr)
            print(f"ðŸ’¡ Fix: {fix}", file=sys.stderr)
            return False

        data = {}
        if session_file.exists():
            data = self._read_json_file(session_file)

        work_dir = Path.cwd()
        data.update({
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "input_fifo": str(input_fifo),
            "output_fifo": str(output_fifo),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "tmux_log": str(runtime / "bridge_output.log"),
            "work_dir": str(work_dir),
            "work_dir_norm": _normalize_path_for_match(str(work_dir)),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        })

        ok, err = safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
        if not ok:
            print(err, file=sys.stderr)
            return False
        return True

    def _write_gemini_session(self, runtime, tmux_session, pane_id=None):
        session_file = Path.cwd() / ".gemini-session"

        # Pre-check permissions
        writable, reason, fix = check_session_writable(session_file)
        if not writable:
            print(f"âŒ Cannot write {session_file.name}: {reason}", file=sys.stderr)
            print(f"ðŸ’¡ Fix: {fix}", file=sys.stderr)
            return False

        data = {
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        ok, err = safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
        if not ok:
            print(err, file=sys.stderr)
            return False
        return True

    def _claude_project_dir(self, work_dir: Path) -> Path:
        projects_root = Path.home() / ".claude" / "projects"
        # Claude Code uses a filesystem-friendly key derived from the working directory.
        # To handle symlinked paths (PWD) vs physical paths (resolve()), try multiple candidates.
        candidates: list[Path] = []
        env_pwd = os.environ.get("PWD")
        if env_pwd:
            try:
                candidates.append(Path(env_pwd))
            except Exception:
                pass
        candidates.extend([work_dir])
        try:
            candidates.append(work_dir.resolve())
        except Exception:
            pass

        for candidate in candidates:
            key = re.sub(r"[^A-Za-z0-9]", "-", str(candidate))
            project_dir = projects_root / key
            if project_dir.exists():
                return project_dir

        # Fallback to a best-effort key even if the directory doesn't exist yet.
        try:
            fallback_path = work_dir.resolve()
        except Exception:
            fallback_path = work_dir
        key = re.sub(r"[^A-Za-z0-9]", "-", str(fallback_path))
        return projects_root / key

    def _get_latest_claude_session_id(self) -> tuple[str | None, bool]:
        """
        Returns (session_id, has_any_history).
        - session_id: latest UUID-like session id if found (for `claude --resume <id>`).
        - has_any_history: whether this project has any Claude sessions on disk.
        """
        project_dir = self._claude_project_dir(Path.cwd())
        if not project_dir.exists():
            return None, False

        session_files = list(project_dir.glob("*.jsonl"))
        if not session_files:
            return None, False

        session_env_root = Path.home() / ".claude" / "session-env"

        uuid_sessions: list[Path] = []
        for session_file in session_files:
            try:
                uuid.UUID(session_file.stem)
                # Ignore zero-byte placeholders and sessions Claude cannot actually resume.
                if session_file.stat().st_size <= 0:
                    continue
                if not (session_env_root / session_file.stem).exists():
                    continue
                uuid_sessions.append(session_file)
            except Exception:
                continue

        if not uuid_sessions:
            return None, True

        latest = max(uuid_sessions, key=lambda p: p.stat().st_mtime)
        return latest.stem, True

    def _find_claude_cmd(self) -> str:
        """Find Claude CLI executable"""
        if sys.platform == "win32":
            for cmd in ["claude.exe", "claude.cmd", "claude.bat", "claude"]:
                path = shutil.which(cmd)
                if path:
                    return path
            npm_paths = [
                Path(os.environ.get("APPDATA", "")) / "npm" / "claude.cmd",
                Path(os.environ.get("ProgramFiles", "")) / "nodejs" / "claude.cmd",
            ]
            for npm_path in npm_paths:
                if npm_path.exists():
                    return str(npm_path)
        else:
            path = shutil.which("claude")
            if path:
                return path
        raise FileNotFoundError(
            "âŒ Claude CLI not found. Install: npm install -g @anthropic-ai/claude-code"
        )

    def _start_claude(self) -> int:
        print(f"ðŸš€ {t('starting_claude')}")

        env = os.environ.copy()
        if "codex" in self.providers:
            runtime = self.runtime_dir / "codex"
            env["CODEX_SESSION_ID"] = self.session_id
            env["CODEX_RUNTIME_DIR"] = str(runtime)
            env["CODEX_INPUT_FIFO"] = str(runtime / "input.fifo")
            env["CODEX_OUTPUT_FIFO"] = str(runtime / "output.fifo")
            env["CODEX_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["CODEX_WEZTERM_PANE"] = self.wezterm_panes.get("codex", "")
            elif self.terminal_type == "iterm2":
                env["CODEX_ITERM2_PANE"] = self.iterm2_panes.get("codex", "")
            else:
                env["CODEX_TMUX_SESSION"] = self.tmux_sessions.get("codex", "")

        if "gemini" in self.providers:
            runtime = self.runtime_dir / "gemini"
            env["GEMINI_SESSION_ID"] = self.session_id
            env["GEMINI_RUNTIME_DIR"] = str(runtime)
            env["GEMINI_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["GEMINI_WEZTERM_PANE"] = self.wezterm_panes.get("gemini", "")
            elif self.terminal_type == "iterm2":
                env["GEMINI_ITERM2_PANE"] = self.iterm2_panes.get("gemini", "")
            else:
                env["GEMINI_TMUX_SESSION"] = self.tmux_sessions.get("gemini", "")

        try:
            claude_cmd = self._find_claude_cmd()
        except FileNotFoundError as e:
            print(str(e))
            return 1

        cmd = [claude_cmd]
        if self.auto:
            cmd.append("--dangerously-skip-permissions")
        if self.resume:
            _, has_history = self._get_latest_claude_session_id()
            if has_history:
                cmd.append("--continue")
                print(f"ðŸ” {t('resuming_claude', session_id='')}")
            else:
                print(f"â„¹ï¸ {t('no_claude_session')}")

        print(f"ðŸ“‹ Session ID: {self.session_id}")
        print(f"ðŸ“ Runtime dir: {self.runtime_dir}")
        print(f"ðŸ”Œ Active backends: {', '.join(self.providers)}")
        print()
        print("ðŸŽ¯ Available commands:")
        if "codex" in self.providers:
            print("   cask/cask-w/cping/cpend - Codex communication")
        if "gemini" in self.providers:
            print("   gask/gask-w/gping/gpend - Gemini communication")
        print()
        print(f"Executing: {' '.join(cmd)}")

        try:
            return subprocess.run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, env=env).returncode
        except KeyboardInterrupt:
            print(f"\nâš ï¸ {t('user_interrupted')}")
            return 130

    def cleanup(self):
        if self._cleaned:
            return
        self._cleaned = True
        print(f"\nðŸ§¹ {t('cleaning_up')}")

        if self.terminal_type == "wezterm":
            backend = WeztermBackend()
            for provider, pane_id in self.wezterm_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        elif self.terminal_type == "iterm2":
            backend = Iterm2Backend()
            for provider, pane_id in self.iterm2_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        else:
            for provider, tmux_session in self.tmux_sessions.items():
                subprocess.run(["tmux", "kill-session", "-t", tmux_session], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{tmux_session}"], stderr=subprocess.DEVNULL)

        for session_file in [Path.cwd() / ".codex-session", Path.cwd() / ".gemini-session", Path.cwd() / ".claude-session"]:
            if session_file.exists():
                try:
                    data = self._read_json_file(session_file)
                    if not data:
                        continue
                    data["active"] = False
                    data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                    safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))
                except Exception:
                    pass

        import shutil
        if self.runtime_dir.exists():
            shutil.rmtree(self.runtime_dir, ignore_errors=True)

        print(f"âœ… {t('cleanup_complete')}")

    def run_up(self) -> int:
        git_info = _get_git_info()
        version_str = f"v{VERSION}" + (f" ({git_info})" if git_info else "")
        print(f"ðŸš€ Claude Code Bridge {version_str}")
        print(f"ðŸ“… {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ðŸ”Œ Backends: {', '.join(self.providers)}")
        print("=" * 50)

        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        providers = list(self.providers)
        if self.terminal_type in ("wezterm", "iterm2"):
            # Stable layout: codex on top, gemini on bottom (when both are present).
            order = {"codex": 0, "gemini": 1}
            providers.sort(key=lambda p: order.get(p, 99))

        for provider in providers:
            if not self._start_provider(provider):
                return 1
            self._warmup_provider(provider)

        if self.no_claude:
            print(f"âœ… {t('backends_started_no_claude')}")
            print()
            for provider in self.providers:
                if self.terminal_type == "wezterm":
                    pane = self.wezterm_panes.get(provider, "")
                    if pane:
                        print(f"   {provider}: wezterm cli activate-pane --pane-id {pane}")
                elif self.terminal_type == "iterm2":
                    pane = self.iterm2_panes.get(provider, "")
                    if pane:
                        print(f"   {provider}: it2 session focus {pane}")
                else:
                    tmux = self.tmux_sessions.get(provider, "")
                    if tmux:
                        print(f"   {provider}: tmux attach -t {tmux}")
            print()
            print(f"Kill: ccb kill {' '.join(self.providers)}")
            atexit.unregister(self.cleanup)
            return 0

        try:
            return self._start_claude()
        finally:
            self.cleanup()


def cmd_up(args):
    launcher = AILauncher(
        providers=args.providers or ["codex"],
        resume=args.resume,
        auto=args.auto,
        no_claude=args.no_claude,
    )
    return launcher.run_up()


def cmd_status(args):
    providers = args.providers or ["codex", "gemini"]
    results = {}

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            results[provider] = {"status": "Not configured", "active": False}
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                alive = backend.is_alive(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                alive = backend.is_alive(pane_id)
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                alive = result.returncode == 0
            else:
                alive = False

            results[provider] = {
                "status": "Running" if (active and alive) else "Stopped",
                "active": active and alive,
                "terminal": terminal,
                "pane_id": pane_id,
                "runtime_dir": data.get("runtime_dir", ""),
            }
        except Exception as e:
            results[provider] = {"status": f"Error: {e}", "active": False}

    print(f"ðŸ“Š {t('backend_status')}")
    for provider, info in results.items():
        icon = "âœ…" if info.get("active") else "âŒ"
        print(f"  {icon} {provider.capitalize()}: {info['status']}")
        if info.get("pane_id"):
            print(f"     {info.get('terminal', 'tmux')}: {info['pane_id']}")

    return 0


def cmd_kill(args):
    providers = args.providers or ["codex", "gemini"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: Session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                backend.kill_pane(pane_id)
            elif pane_id and shutil.which("tmux"):
                subprocess.run(["tmux", "kill-session", "-t", pane_id], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{pane_id}"], stderr=subprocess.DEVNULL)

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            safe_write_session(session_file, json.dumps(data, ensure_ascii=False, indent=2))

            print(f"âœ… {provider.capitalize()} terminated")
        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def cmd_restore(args):
    providers = args.providers or ["codex"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: Session file not found")
            continue

        try:
            data = json.loads(session_file.read_text(encoding="utf-8-sig"))
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal in ("wezterm", "iterm2") else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif terminal == "iterm2" and pane_id:
                backend = Iterm2Backend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif pane_id and shutil.which("tmux"):
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                if result.returncode == 0:
                    subprocess.run(["tmux", "attach-session", "-t", pane_id])
                    return 0

            if not active:
                has_history = False
                session_id = None
                if provider == "codex":
                    session_id = data.get("codex_session_id")
                    if isinstance(session_id, str) and session_id:
                        recorded_norm = _extract_session_work_dir_norm(data)
                        work_keys = _work_dir_match_keys(Path.cwd())
                        if recorded_norm and (not work_keys or recorded_norm in work_keys):
                            has_history = True
                        else:
                            session_id = None
                    else:
                        # Fallback: scan ~/.codex/sessions for latest session bound to this cwd.
                        root = Path(os.environ.get("CODEX_SESSION_ROOT") or (Path.home() / ".codex" / "sessions")).expanduser()
                        work_dirs = _work_dir_match_keys(Path.cwd())
                        try:
                            logs = sorted(
                                (p for p in root.glob("**/*.jsonl") if p.is_file()),
                                key=lambda p: p.stat().st_mtime,
                                reverse=True,
                            )
                        except Exception:
                            logs = []
                        for log_path in logs[:400]:
                            try:
                                with log_path.open("r", encoding="utf-8", errors="ignore") as handle:
                                    first = handle.readline().strip()
                            except OSError:
                                continue
                            if not first:
                                continue
                            try:
                                entry = json.loads(first)
                            except Exception:
                                continue
                            if not isinstance(entry, dict) or entry.get("type") != "session_meta":
                                continue
                            payload = entry.get("payload") if isinstance(entry.get("payload"), dict) else {}
                            cwd = payload.get("cwd")
                            if isinstance(cwd, str) and cwd.strip() and _normalize_path_for_match(cwd) in work_dirs:
                                has_history = True
                                sid = payload.get("id")
                                if isinstance(sid, str) and sid:
                                    session_id = sid
                                    break
                elif provider == "gemini":
                    gemini_root = Path.home() / ".gemini" / "tmp"
                    if gemini_root.exists():
                        import hashlib
                        candidates = [os.environ.get("PWD", ""), str(Path.cwd())]
                        try:
                            candidates.append(str(Path.cwd().resolve()))
                        except Exception:
                            pass
                        for candidate in candidates:
                            if not candidate:
                                continue
                            project_hash = hashlib.sha256(candidate.encode()).hexdigest()
                            chats_dir = gemini_root / project_hash / "chats"
                            if chats_dir.exists() and any(chats_dir.glob("session-*.json")):
                                has_history = True
                                break

                if has_history:
                    print(f"â„¹ï¸ {provider}: Session ended but history recoverable")
                    if session_id:
                        print(f"   Session ID: {session_id[:8]}...")
                    print(f"   Use: ccb up {provider} -r")
                else:
                    print(f"âš ï¸ {provider}: Session ended, no recoverable history")
            else:
                print(f"âš ï¸ {provider}: Session lost, use ccb up {provider} -r to restart")

        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def _get_version_info(dir_path: Path) -> dict:
    """Get commit hash, date and version from install directory"""
    info = {"commit": None, "date": None, "version": None}
    ccb_file = dir_path / "ccb"
    if ccb_file.exists():
        try:
            content = ccb_file.read_text(encoding='utf-8', errors='replace')
            for line in content.split('\n')[:60]:
                line = line.strip()
                if line.startswith('VERSION') and '=' in line:
                    info["version"] = line.split('=')[1].strip().strip('"').strip("'")
                elif line.startswith('GIT_COMMIT') and '=' in line:
                    val = line.split('=')[1].strip().strip('"').strip("'")
                    if val:
                        info["commit"] = val
                elif line.startswith('GIT_DATE') and '=' in line:
                    val = line.split('=')[1].strip().strip('"').strip("'")
                    if val:
                        info["date"] = val
        except Exception:
            pass
    if shutil.which("git") and (dir_path / ".git").exists():
        result = subprocess.run(
            ["git", "-C", str(dir_path), "log", "-1", "--format=%h|%ci"],
            capture_output=True, text=True, encoding='utf-8', errors='replace'
        )
        if result.returncode == 0 and result.stdout.strip():
            parts = result.stdout.strip().split("|")
            if len(parts) >= 2:
                info["commit"] = parts[0]
                info["date"] = parts[1].split()[0]
    return info


def _format_version_info(info: dict) -> str:
    """Format version info for display"""
    parts = []
    if info.get("version"):
        parts.append(f"v{info['version']}")
    if info.get("commit"):
        parts.append(info["commit"])
    if info.get("date"):
        parts.append(info["date"])
    return " ".join(parts) if parts else "unknown"


def _get_remote_version_info() -> dict | None:
    """Get latest version info from GitHub API"""
    import urllib.request
    import ssl

    api_url = "https://api.github.com/repos/yemingxin666/claude_code_bridge/commits/main"
    try:
        ctx = ssl.create_default_context()
        req = urllib.request.Request(api_url, headers={"User-Agent": "ccb"})
        with urllib.request.urlopen(req, context=ctx, timeout=5) as resp:
            data = json.loads(resp.read().decode('utf-8'))
            commit = data.get("sha", "")[:7]
            date_str = data.get("commit", {}).get("committer", {}).get("date", "")
            date = date_str[:10] if date_str else None
            return {"commit": commit, "date": date}
    except Exception:
        pass

    if shutil.which("curl"):
        result = subprocess.run(
            ["curl", "-fsSL", api_url],
            capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=10
        )
        if result.returncode == 0:
            try:
                data = json.loads(result.stdout)
                commit = data.get("sha", "")[:7]
                date_str = data.get("commit", {}).get("committer", {}).get("date", "")
                date = date_str[:10] if date_str else None
                return {"commit": commit, "date": date}
            except Exception:
                pass
    return None


def cmd_version(args):
    """Show version info and check for updates"""
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root

    local_info = _get_version_info(install_dir)
    local_str = _format_version_info(local_info)

    print(f"ccb (Claude Code Bridge) {local_str}")
    print(f"Install path: {install_dir}")

    print("\nChecking for updates...")
    remote_info = _get_remote_version_info()

    if remote_info is None:
        print("âš ï¸  Unable to check for updates (network error)")
    elif local_info.get("commit") and remote_info.get("commit"):
        if local_info["commit"] == remote_info["commit"]:
            print(f"âœ… Up to date")
        else:
            remote_str = f"{remote_info['commit']} {remote_info.get('date', '')}"
            print(f"ðŸ“¦ Update available: {remote_str}")
            print(f"   Run: ccb update")
    else:
        print("âš ï¸  Unable to compare versions")

    return 0


def cmd_update(args):
    """Update ccb to latest version"""
    import urllib.request
    import tarfile
    import tempfile

    # Prefer the directory where this script resides (installed copy), then fall back to env/default.
    script_root = Path(__file__).resolve().parent
    default_install_dir = Path.home() / ".local/share/codex-dual"
    install_dir = Path(os.environ.get("CODEX_INSTALL_PREFIX") or default_install_dir).expanduser()
    if (script_root / "install.sh").exists():
        install_dir = script_root
    repo_url = "https://github.com/yemingxin666/claude_code_bridge"

    # Get current version info before update
    old_info = _get_version_info(install_dir)

    print("ðŸ”„ Checking for updates...")

    # Method 1: Prefer git if available
    if shutil.which("git") and (install_dir / ".git").exists():
        print("ðŸ“¦ Updating via git pull...")
        result = subprocess.run(
            ["git", "-C", str(install_dir), "pull", "--ff-only"],
            capture_output=True, text=True, encoding='utf-8', errors='replace'
        )
        if result.returncode == 0:
            print(result.stdout.strip() if result.stdout.strip() else "Already up to date.")
            print("ðŸ”§ Reinstalling...")
            subprocess.run([str(install_dir / "install.sh"), "install"])
            # Show upgrade info
            new_info = _get_version_info(install_dir)
            old_str = _format_version_info(old_info)
            new_str = _format_version_info(new_info)
            if old_info.get("commit") != new_info.get("commit"):
                print(f"âœ… Updated: {old_str} â†’ {new_str}")
            else:
                print(f"âœ… Already up to date: {new_str}")
            return 0
        else:
            print(f"âš ï¸ Git pull failed: {result.stderr.strip()}")
            print("Falling back to tarball download...")

    def _pick_temp_base_dir() -> Path:
        candidates: list[Path] = []
        for key in ("CCB_TMPDIR", "TMPDIR", "TEMP", "TMP"):
            value = (os.environ.get(key) or "").strip()
            if value:
                candidates.append(Path(value).expanduser())
        try:
            candidates.append(Path(tempfile.gettempdir()))
        except Exception:
            pass
        candidates.extend(
            [
                Path("/tmp"),
                Path("/var/tmp"),
                Path("/usr/tmp"),
                Path.home() / ".cache" / "ccb" / "tmp",
                install_dir / ".tmp",
                Path.cwd() / ".tmp",
            ]
        )

        for base in candidates:
            try:
                base.mkdir(parents=True, exist_ok=True)
                probe = base / f".ccb_tmp_probe_{os.getpid()}_{int(time.time() * 1000)}"
                probe.write_bytes(b"1")
                probe.unlink(missing_ok=True)
                return base
            except Exception:
                continue

        raise RuntimeError(
            "âŒ No usable temporary directory found.\n"
            "Fix options:\n"
            "  - Create /tmp (Linux/WSL): sudo mkdir -p /tmp && sudo chmod 1777 /tmp\n"
            "  - Or set TMPDIR/CCB_TMPDIR to a writable path (e.g. export TMPDIR=$HOME/.cache/tmp)"
        )

    # Method 2: Download tarball
    tarball_url = f"{repo_url}/archive/refs/heads/main.tar.gz"
    try:
        tmp_base = _pick_temp_base_dir()
    except Exception as exc:
        print(str(exc))
        return 1
    tmp_dir = tmp_base / "ccb_update"

    try:
        print(f"ðŸ“¥ Downloading latest version...")
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir)
        tmp_dir.mkdir(parents=True, exist_ok=True)
        tarball_path = tmp_dir / "main.tar.gz"

        # Prefer curl/wget (better certificate handling)
        downloaded = False
        if shutil.which("curl"):
            result = subprocess.run(
                ["curl", "-fsSL", "-o", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded and shutil.which("wget"):
            result = subprocess.run(
                ["wget", "-q", "-O", str(tarball_path), tarball_url],
                capture_output=True
            )
            downloaded = result.returncode == 0
        if not downloaded:
            # Fallback to urllib (may have SSL issues)
            import ssl
            try:
                urllib.request.urlretrieve(tarball_url, tarball_path)
            except ssl.SSLError:
                print("âš ï¸ SSL certificate verification failed, trying to skip...")
                ctx = ssl.create_default_context()
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE
                with urllib.request.urlopen(tarball_url, context=ctx) as resp:
                    tarball_path.write_bytes(resp.read())

        print("ðŸ“‚ Extracting...")
        def _safe_extract(tar: tarfile.TarFile, dest: Path) -> None:
            dest = dest.resolve()
            for member in tar.getmembers():
                member_path = (dest / member.name).resolve()
                if not str(member_path).startswith(str(dest) + os.sep):
                    raise RuntimeError(f"Unsafe tar member path: {member.name}")
            # Python 3.14+ requires filter argument
            try:
                tar.extractall(dest, filter='data')
            except TypeError:
                tar.extractall(dest)

        with tarfile.open(tarball_path, "r:gz") as tar:
            _safe_extract(tar, tmp_dir)

        extracted_dir = tmp_dir / "claude_code_bridge-main"

        print("ðŸ”§ Installing...")
        env = os.environ.copy()
        env["CODEX_INSTALL_PREFIX"] = str(install_dir)
        # Windows: use install.ps1, Unix: use install.sh
        if platform.system() == "Windows":
            ps1_script = extracted_dir / "install.ps1"
            subprocess.run(
                ["powershell", "-ExecutionPolicy", "Bypass", "-File", str(ps1_script), "install"],
                check=True, env=env
            )
        else:
            subprocess.run([str(extracted_dir / "install.sh"), "install"], check=True, env=env)

        # Show upgrade info
        new_info = _get_version_info(install_dir)
        old_str = _format_version_info(old_info)
        new_str = _format_version_info(new_info)
        if old_info.get("commit") != new_info.get("commit") or old_info.get("version") != new_info.get("version"):
            print(f"âœ… Updated: {old_str} â†’ {new_str}")
        else:
            print(f"âœ… Already up to date: {new_str}")
        return 0

    except Exception as e:
        print(f"âŒ Update failed: {e}")
        return 1

    finally:
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(description="Claude AI unified launcher", add_help=True)
    subparsers = parser.add_subparsers(dest="command", help="Subcommands")

    # up subcommand
    up_parser = subparsers.add_parser("up", help="Start AI backends")
    up_parser.add_argument("providers", nargs="*", choices=["codex", "gemini"], help="Backends to start")
    up_parser.add_argument("-r", "--resume", "--restore", action="store_true", help="Resume context")
    up_parser.add_argument("-a", "--auto", action="store_true", help="Full auto permission mode")
    up_parser.add_argument("--no-claude", action="store_true", help="Don't start Claude main window")

    # status subcommand
    status_parser = subparsers.add_parser("status", help="Check status")
    status_parser.add_argument("providers", nargs="*", default=[], help="Backends to check (codex/gemini)")

    # kill subcommand
    kill_parser = subparsers.add_parser("kill", help="Terminate session")
    kill_parser.add_argument("providers", nargs="*", default=[], help="Backends to terminate (codex/gemini)")

    # restore subcommand
    restore_parser = subparsers.add_parser("restore", help="Restore/attach session")
    restore_parser.add_argument("providers", nargs="*", default=[], help="Backends to restore (codex/gemini)")

    # update subcommand
    subparsers.add_parser("update", help="Update to latest version")

    # version subcommand
    subparsers.add_parser("version", help="Show version and check for updates")

    argv = sys.argv[1:]
    # Backward/shortcut compatibility
    if argv and argv[0] in {"-r", "--resume", "--restore"}:
        argv = ["up"] + argv
    elif argv and argv[0] in {"-v", "--version"}:
        argv = ["version"]
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "status":
        return cmd_status(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "restore":
        return cmd_restore(args)
    elif args.command == "update":
        return cmd_update(args)
    elif args.command == "version":
        return cmd_version(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
